name: Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      version:
        description: "å‘å¸ƒç‰ˆæœ¬å·ï¼ˆç¤ºä¾‹ï¼š1.2 æˆ– 1.2.3ï¼‰"
        required: true
        default: "1.1"

permissions:
  contents: write

jobs:
  build:
    runs-on: windows-latest

    strategy:
      matrix:
        arch: [x64, x86]

    outputs:
      release_tag: ${{ steps.prepare_version.outputs.release_tag }}
      release_version: ${{ steps.prepare_version.outputs.release_version }}

    steps:
    - name: æ£€å‡ºä»“åº“
      uses: actions/checkout@v4

    # ç»Ÿä¸€ç‰ˆæœ¬å·ä¸ tagï¼Œå…¼å®¹ tag è§¦å‘ä¸æ‰‹åŠ¨è§¦å‘
    - name: å‡†å¤‡ç‰ˆæœ¬å·
      id: prepare_version
      shell: pwsh
      run: |
        if ("${{ github.event_name }}" -eq "workflow_dispatch") {
          $rawVersion = "${{ inputs.version }}"
          $normalized = $rawVersion.Trim()
          if ($normalized.StartsWith("v")) { $normalized = $normalized.Substring(1) }
          $tag = "v$normalized"
        } else {
          $tag = "${{ github.ref_name }}"
          $normalized = $tag
          if ($normalized.StartsWith("v")) { $normalized = $normalized.Substring(1) }
        }
        "release_tag=$tag" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
        "release_version=$normalized" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

    # å°†æœ¬æ¬¡å‘å¸ƒç‰ˆæœ¬å·åŒæ­¥åˆ° build.ps1ï¼Œç¡®ä¿äº§ç‰©å†…ç‰ˆæœ¬å·ä¸ tag ä¸€è‡´
    - name: åŒæ­¥ç‰ˆæœ¬å·åˆ° build.ps1
      shell: pwsh
      run: |
        $ver = "${{ steps.prepare_version.outputs.release_version }}"
        if ([string]::IsNullOrWhiteSpace($ver)) {
          Write-Error "å‘å¸ƒç‰ˆæœ¬å·ä¸ºç©ºï¼Œæ— æ³•åŒæ­¥åˆ° build.ps1"
          exit 1
        }

        $path = Join-Path $env:GITHUB_WORKSPACE "build.ps1"
        if (-not (Test-Path $path)) {
          Write-Error "æœªæ‰¾åˆ° build.ps1ï¼š$path"
          exit 1
        }

        $content = Get-Content -Path $path -Raw -Encoding UTF8
        $pattern = '(?m)^\s*\$Version\s*=\s*".*?"\s*$'
        if (-not [regex]::IsMatch($content, $pattern)) {
          Write-Error "æœªåœ¨ build.ps1 ä¸­æ‰¾åˆ° `$Version = \"...\"` ç‰ˆæœ¬å·è¡Œï¼Œæ— æ³•è‡ªåŠ¨æ›´æ–°ã€‚"
          exit 1
        }

        $replacement = ('$Version = "{0}"' -f $ver)
        $newContent = [regex]::Replace($content, $pattern, $replacement, 1)
        Set-Content -Path $path -Value $newContent -Encoding UTF8
        Write-Host "å·²åŒæ­¥ build.ps1 ç‰ˆæœ¬å·ä¸ºï¼š$ver"

    # ä½¿ç”¨ build.ps1 ç»Ÿä¸€ç¼–è¯‘é€»è¾‘ï¼Œé¿å…ä¸æœ¬åœ°æµç¨‹åå·®
    - name: æ‰§è¡Œç¼–è¯‘è„šæœ¬ï¼ˆReleaseï¼Œå…ˆæ¸…ç†ï¼‰
      shell: pwsh
      run: .\build.ps1 -Clean -Config Release -Arch ${{ matrix.arch }}

    # æ‰“åŒ… output ç›®å½•ä¸º Release èµ„äº§
    - name: æ‰“åŒ…äº§ç‰©
      id: package
      shell: pwsh
      run: |
        $zipName = "antigravity-proxy-${{ steps.prepare_version.outputs.release_tag }}-win-${{ matrix.arch }}.zip"
        $zipPath = Join-Path $env:RUNNER_TEMP $zipName
        if (Test-Path $zipPath) { Remove-Item -Force $zipPath }
        Compress-Archive -Path "output/*" -DestinationPath $zipPath -Force
        "zip_path=$zipPath" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

    # ä¸Šä¼  zipï¼Œä¾›å‘å¸ƒä½œä¸šç»Ÿä¸€ä¸Šä¼ åˆ° Release
    - name: ä¸Šä¼ æ‰“åŒ…æ–‡ä»¶
      uses: actions/upload-artifact@v4
      with:
        name: release-asset-${{ matrix.arch }}
        path: ${{ steps.package.outputs.zip_path }}
        if-no-files-found: error

  release:
    runs-on: ubuntu-latest
    needs: build

    steps:
    # æ£€å‡ºä»“åº“ä»¥è·å– git å†å²è®°å½•ï¼ˆç”Ÿæˆå‘å¸ƒè¯´æ˜éœ€è¦ï¼‰
    - name: æ£€å‡ºä»“åº“
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    # åŸºäº git æäº¤å†å²ç”Ÿæˆç»“æ„åŒ–å‘å¸ƒè¯´æ˜
    - name: ç”Ÿæˆå‘å¸ƒè¯´æ˜
      id: changelog
      shell: bash
      run: |
        set -euo pipefail
        CURRENT_TAG="${{ needs.build.outputs.release_tag }}"
        
        # è·å–ä¸Šä¸€ä¸ª tagï¼ˆæ’é™¤å½“å‰ tagï¼‰
        PREV_TAG=$(git tag --sort=-version:refname | grep -E '^v[0-9]' | grep -v "^${CURRENT_TAG}$" | head -n 1 || true)
        
        if [ -z "${PREV_TAG:-}" ]; then
          echo "é¦–æ¬¡å‘å¸ƒï¼Œè·å–æ‰€æœ‰æäº¤è®°å½•"
          COMMIT_RANGE="HEAD"
        else
          echo "ä» $PREV_TAG åˆ° $CURRENT_TAG çš„æäº¤"
          COMMIT_RANGE="${PREV_TAG}..HEAD"
        fi
        
        trim() {
          local s="$1"
          s="${s//$'\r'/}"
          # ä½¿ç”¨ sed å»é™¤é¦–å°¾ç©ºç™½ï¼ˆæ›´å…¼å®¹ï¼Œé¿å… extglob è§£æé—®é¢˜ï¼‰
          s="$(printf '%s' "$s" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
          printf '%s' "$s"
        }
        
        # å»æ‰è¡Œå†…çš„ ```fenceï¼ˆå¸¸è§äºå¤åˆ¶ç²˜è´´æ—¶æŠŠ commit ä¿¡æ¯åŒ…åœ¨ ``` é‡Œï¼‰
        strip_inline_fence() {
          local s
          local fence='```'
          s="$(trim "$1")"
        
          # leading fence: ```lang? <content?>
          if [[ "$s" == "$fence"* ]]; then
            s="${s#"$fence"}"
            s="$(trim "$s")"
        
            # å¦‚æœåªæœ‰è¯­è¨€æ ‡è®°ï¼ˆå¦‚ ```textï¼‰ï¼Œè§†ä¸ºçº¯åŒ…è£¹è¡Œï¼Œç›´æ¥ä¸¢å¼ƒ
            if [[ "$s" =~ ^[[:alnum:]_-]+$ ]]; then
              s=""
            # è‹¥å½¢å¦‚ "lang <content>"ï¼Œå»æ‰ langï¼Œä¿ç•™ content
            elif [[ "$s" =~ ^[[:alnum:]_-]+[[:space:]]+(.*)$ ]]; then
              s="$(trim "${BASH_REMATCH[1]}")"
            fi
          fi
        
          # trailing fence: ... ```
          if [[ "$s" == *"$fence" ]]; then
            s="${s%"$fence"}"
            s="$(trim "$s")"
          fi
        
          printf '%s' "$s"
        }
        
        # ä»…è½¬ä¹‰åå¼•å·ï¼Œé¿å… ``` è§¦å‘ code fence æˆ– `...` è§¦å‘ inline code ç ´ååˆ—è¡¨ç»“æ„
        md_escape_backticks() {
          local s="$1"
          local tick='`'
          s="${s//${tick}/\\${tick}}"
          printf '%s' "$s"
        }
        
        format_body_as_sublist() {
          local body="$1"
          body="$(trim "$body")"
          [ -z "$body" ] && return 0
        
          local out=""
          local line=""
          while IFS= read -r line; do
            line="$(trim "$line")"
            [ -z "$line" ] && continue
        
            # å»æ‰å•è¡Œ fenceï¼Œé¿å…ç ´å Markdownï¼ˆåŒæ—¶ä¹Ÿå…¼å®¹ AI è¾“å‡ºé‡Œå¤šä½™çš„ ``` åŒ…è£¹ï¼‰
            if [[ "$line" =~ ^\`\`\` ]]; then
              continue
            fi
        
            # å»æ‰å¸¸è§åˆ—è¡¨å‰ç¼€ï¼ˆ- / * / + / 1.ï¼‰
            line="$(printf '%s' "$line" | sed -E 's/^([-*+]|[0-9]+\.)[[:space:]]+//')"
            line="$(trim "$line")"
            [ -z "$line" ] && continue
        
            line="$(md_escape_backticks "$line")"
            out+="  - ${line}"$'\n'
          done <<< "$body"
        
          out="${out%$'\n'}"
          [ -n "$out" ] && printf '%s' "$out"
        }

        # Conventional Commits æ­£åˆ™ï¼šæ”¾å…¥å˜é‡ä¸­ï¼Œé¿å… bash åœ¨ [[ ... =~ ... ]] ä¸­å°† ()/! è¯¯è§£æä¸ºæ¡ä»¶è¯­æ³•
        CC_HEADER_RE='^[a-zA-Z]+(\([^)]+\))?(!)?:'
        CC_FULL_RE='^([a-zA-Z]+)(\(([^)]+)\))?(!)?:[[:space:]]*(.+)$'
        
        # åˆ›å»ºä¸´æ—¶æ–‡ä»¶å­˜å‚¨å„ç±»å‹æäº¤
        TMPDIR=$(mktemp -d)
        for type in feat fix perf refactor docs chore style test build ci other; do
          : > "$TMPDIR/$type.txt"
        done
        
        # è·å–æäº¤åˆ—è¡¨ï¼šsha + subject + bodyï¼ˆä¸€æ¬¡æ€§è¾“å‡ºï¼Œé¿å…å¾ªç¯ä¸­é‡å¤è°ƒç”¨ git logï¼‰
        while IFS= read -r -d $'\x1e' record; do
          record="${record%$'\n'}"
          [ -z "$record" ] && continue
        
          sha="${record%%$'\n'*}"
          rest="${record#*$'\n'}"
          subject_raw="${rest%%$'\n'*}"
          body_raw="${rest#*$'\n'}"
        
          sha="$(trim "$sha")"
          subject_raw="$(trim "$subject_raw")"
          body_raw="${body_raw//$'\r'/}"
        
          # è§„èŒƒåŒ– subjectï¼Œå»æ‰ ``` åŒ…è£¹/å‰ç¼€ï¼Œé¿å…è¯¯åˆ†ç±»åˆ° other
          subject="$(strip_inline_fence "$subject_raw")"
          body="$body_raw"
        
          # è‹¥ subject ä¸ºç©ºæˆ–ä¸åƒ Conventional Commitsï¼Œå°è¯•ä» body æå–ç¬¬ä¸€æ¡ç¬¦åˆæ ¼å¼çš„è¡Œä½œä¸º subject
          promoted_subject=""
          if [ -z "$subject" ] || ! [[ "$subject" =~ $CC_HEADER_RE ]]; then
            new_body=""
            while IFS= read -r line; do
              line="$(trim "$line")"
              [ -z "$line" ] && continue
        
              if [[ "$line" =~ ^\`\`\` ]]; then
                continue
              fi
        
              if [ -z "$promoted_subject" ] && [[ "$line" =~ $CC_HEADER_RE ]]; then
                promoted_subject="$(strip_inline_fence "$line")"
                continue
              fi
        
              new_body+="$line"$'\n'
            done <<< "$body_raw"
            body="$(trim "$new_body")"
        
            if [ -n "$promoted_subject" ]; then
              subject="$promoted_subject"
            fi
          fi
        
          subject="$(trim "$subject")"
        
          # è§£æ Conventional Commitsï¼štype(scope)!: description
          if [[ "$subject" =~ $CC_FULL_RE ]]; then
            TYPE="${BASH_REMATCH[1],,}"
            SCOPE="$(trim "${BASH_REMATCH[3]}")"
            DESC="$(trim "${BASH_REMATCH[5]}")"
        
            scope_safe="$(md_escape_backticks "$SCOPE")"
            desc_safe="$(md_escape_backticks "$DESC")"
        
            if [ -n "$SCOPE" ] && [ "$SCOPE" != "$TYPE" ]; then
              ENTRY="- **${scope_safe}**: ${desc_safe} (\`${sha}\`)"
            else
              ENTRY="- ${desc_safe} (\`${sha}\`)"
            fi
        
            body_out="$(format_body_as_sublist "$body" || true)"
            if [ -n "${body_out:-}" ]; then
              ENTRY+=$'\n'"$body_out"
            fi
        
            case "$TYPE" in
              feat)     printf '%s\n' "$ENTRY" >> "$TMPDIR/feat.txt" ;;
              fix)      printf '%s\n' "$ENTRY" >> "$TMPDIR/fix.txt" ;;
              perf)     printf '%s\n' "$ENTRY" >> "$TMPDIR/perf.txt" ;;
              refactor) printf '%s\n' "$ENTRY" >> "$TMPDIR/refactor.txt" ;;
              docs)     printf '%s\n' "$ENTRY" >> "$TMPDIR/docs.txt" ;;
              chore)    printf '%s\n' "$ENTRY" >> "$TMPDIR/chore.txt" ;;
              style)    printf '%s\n' "$ENTRY" >> "$TMPDIR/style.txt" ;;
              test)     printf '%s\n' "$ENTRY" >> "$TMPDIR/test.txt" ;;
              build)    printf '%s\n' "$ENTRY" >> "$TMPDIR/build.txt" ;;
              ci)       printf '%s\n' "$ENTRY" >> "$TMPDIR/ci.txt" ;;
              *)        printf '%s\n' "$ENTRY" >> "$TMPDIR/other.txt" ;;
            esac
          else
            # éæ ‡å‡†æ ¼å¼æäº¤ï¼šä¹Ÿè¾“å‡º bodyï¼Œå¹¶åšå¥½ ```/` å¤„ç†ï¼Œé¿å…ç ´å Markdown
            subject_other="$(trim "$(strip_inline_fence "$subject_raw")")"
            subject_other="$(md_escape_backticks "$subject_other")"
            [ -z "$subject_other" ] && subject_other="(no subject)"
        
            ENTRY="- ${subject_other} (\`${sha}\`)"
            body_out="$(format_body_as_sublist "$body_raw" || true)"
            if [ -n "${body_out:-}" ]; then
              ENTRY+=$'\n'"$body_out"
            fi
        
            printf '%s\n' "$ENTRY" >> "$TMPDIR/other.txt"
          fi
        done < <(git log "$COMMIT_RANGE" --no-merges --pretty=format:'%h%n%s%n%b%n%x1e' 2>/dev/null)
        
        # æ„å»ºæœ€ç»ˆçš„å‘å¸ƒè¯´æ˜
        CHANGELOG=""
        
        add_section() {
          local file="$1"
          local title="$2"
          if [ -s "$file" ]; then
            CHANGELOG="${CHANGELOG}${title}"$'\n\n'
            CHANGELOG="${CHANGELOG}$(cat "$file")"$'\n\n'
          fi
        }
        
        add_section "$TMPDIR/feat.txt"     "## âœ¨ æ–°åŠŸèƒ½ (Features)"
        add_section "$TMPDIR/fix.txt"      "## ğŸ› Bug ä¿®å¤ (Bug Fixes)"
        add_section "$TMPDIR/perf.txt"     "## âš¡ æ€§èƒ½ä¼˜åŒ– (Performance)"
        add_section "$TMPDIR/refactor.txt" "## â™»ï¸ ä»£ç é‡æ„ (Refactoring)"
        add_section "$TMPDIR/docs.txt"     "## ğŸ“ æ–‡æ¡£æ›´æ–° (Documentation)"
        add_section "$TMPDIR/build.txt"    "## ğŸ“¦ æ„å»ºç›¸å…³ (Build)"
        add_section "$TMPDIR/ci.txt"       "## ğŸ‘· CI é…ç½® (CI)"
        add_section "$TMPDIR/chore.txt"    "## ğŸ”§ æ‚é¡¹ (Chores)"
        add_section "$TMPDIR/style.txt"    "## ğŸ’„ ä»£ç é£æ ¼ (Style)"
        add_section "$TMPDIR/test.txt"     "## âœ… æµ‹è¯• (Tests)"
        add_section "$TMPDIR/other.txt"    "## ğŸ“‹ å…¶ä»–æ›´æ–° (Other)"
        
        # æ¸…ç†ä¸´æ—¶ç›®å½•
        rm -rf "$TMPDIR"
        
        # å¦‚æœæ²¡æœ‰ä»»ä½•æäº¤è®°å½•
        [ -z "$CHANGELOG" ] && CHANGELOG="æš‚æ— æ›´æ–°è®°å½•"
        
        # ä½¿ç”¨ heredoc å†™å…¥å¤šè¡Œè¾“å‡ºï¼ˆGitHub Actions æ¨èæ–¹å¼ï¼‰
        # ä½¿ç”¨éšæœºåˆ†éš”ç¬¦ï¼Œé¿å… changelog å†…å®¹é‡Œæ°å¥½å‡ºç° EOF å¯¼è‡´æˆªæ–­
        DELIM="CHANGELOG_$(date +%s%N)"
        {
          printf 'body<<%s\n' "$DELIM"
          printf '%s\n' "$CHANGELOG"
          printf '%s\n' "$DELIM"
        } >> "$GITHUB_OUTPUT"

    - name: ä¸‹è½½æ‰“åŒ…æ–‡ä»¶
      uses: actions/download-artifact@v4
      with:
        path: release-assets

    # åˆ›å»º/æ›´æ–° Releaseï¼Œä¸Šä¼ æ‰“åŒ…äº§ç‰©å¹¶ä½¿ç”¨ç”Ÿæˆçš„å‘å¸ƒè¯´æ˜
    - name: å‘å¸ƒ GitHub Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ needs.build.outputs.release_tag }}
        name: ${{ needs.build.outputs.release_tag }}
        target_commitish: ${{ github.sha }}
        files: release-assets/**/*.zip
        body: ${{ steps.changelog.outputs.body }}

    # å°†ç‰ˆæœ¬å·åŒæ­¥å› build.ps1 å¹¶æäº¤åˆ°ä»“åº“
    - name: åŒæ­¥ç‰ˆæœ¬å·åˆ°ä»“åº“
      shell: bash
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        set -euo pipefail
        
        VERSION="${{ needs.build.outputs.release_version }}"
        TAG="${{ needs.build.outputs.release_tag }}"
        
        if [ -z "$VERSION" ]; then
          echo "::warning::ç‰ˆæœ¬å·ä¸ºç©ºï¼Œè·³è¿‡åŒæ­¥"
          exit 0
        fi
        
        echo "å‡†å¤‡åŒæ­¥ç‰ˆæœ¬å·: $VERSION"
        
        # é…ç½® git ç”¨æˆ·èº«ä»½
        git config user.name "github-actions[bot]"
        git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
        
        # è·å–é»˜è®¤åˆ†æ”¯åç§°
        DEFAULT_BRANCH=$(git remote show origin | sed -n '/HEAD branch/s/.*: //p')
        echo "é»˜è®¤åˆ†æ”¯: $DEFAULT_BRANCH"
        
        # åˆ‡æ¢åˆ°é»˜è®¤åˆ†æ”¯å¹¶æ‹‰å–æœ€æ–°ä»£ç 
        git fetch origin "$DEFAULT_BRANCH"
        git checkout "$DEFAULT_BRANCH"
        git pull origin "$DEFAULT_BRANCH"
        
        # æ›´æ–° build.ps1 ä¸­çš„ç‰ˆæœ¬å·
        if [ -f "build.ps1" ]; then
          # ä½¿ç”¨ sed æ›¿æ¢ç‰ˆæœ¬å·è¡Œ
          sed -i -E "s/^\s*\\\$Version\s*=\s*\"[^\"]*\"/\$Version = \"$VERSION\"/" build.ps1
          
          # æ£€æŸ¥æ˜¯å¦æœ‰å®é™…æ›´æ”¹
          if git diff --quiet build.ps1; then
            echo "ç‰ˆæœ¬å·å·²æ˜¯æœ€æ–° ($VERSION)ï¼Œæ— éœ€æ›´æ–°"
            exit 0
          fi
          
          echo "ç‰ˆæœ¬å·å·²æ›´æ–°ä¸º: $VERSION"
          git add build.ps1
          git commit -m "chore: åŒæ­¥ç‰ˆæœ¬å·åˆ° $TAG [skip ci]"
          git push origin "$DEFAULT_BRANCH"
          echo "âœ… ç‰ˆæœ¬å·å·²åŒæ­¥åˆ°ä»“åº“"
        else
          echo "::warning::æœªæ‰¾åˆ° build.ps1 æ–‡ä»¶"
        fi
